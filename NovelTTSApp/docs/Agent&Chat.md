# Agent & Chat: AI 驱动的开发实践

<div align="center">

*记录一次人机协作的开发旅程*

**从零到一，通过对话构建完整应用**

</div>

---

## 🎯 引言

这份文档记录了 **NovelTTSApp** 项目的独特开发方式——通过与 AI 助手的持续对话，完成了一个完整的小说转有声书应用。这不仅是一份技术文档，更是一次探索 **对话驱动开发（Conversation-Driven Development）** 的实践报告。

---

## 📐 开发范式：对话即代码

传统开发流程：

```
需求文档 → 设计 → 编码 → 测试 → 部署
```

本项目的开发流程：

```
自然语言描述 → AI 理解 → 代码生成 → 即时反馈 → 迭代优化
```

### 核心特点

| 传统开发 | 对话驱动开发 |
|----------|--------------|
| 先设计后编码 | 边对话边实现 |
| 需要完整的技术文档 | 规则文件 + 自然语言 |
| 逐个功能开发 | 一次性生成完整架构 |
| 修改需要理解代码 | 描述问题即可修复 |

---

## 🗣️ 对话历程

### 第一幕：项目诞生

**用户的起点很简单**：

> "基于 rules 为我完成完整的应用程序"

这一句话背后，是预先准备好的 `.qoder/rules/novel_tts_app.md` 规则文件。规则文件定义了：

- 技术栈（.NET 10, C# 13）
- 架构模式（Clean Architecture）
- 核心依赖（MEAI, NAudio, Polly...）
- 配置管理（appsettings.json）
- 编码规范（现代 C# 风格）

**AI 助手的响应**：

在理解规则后，AI 一次性完成了：

```
✅ 创建解决方案和三层项目结构
✅ 安装 NuGet 依赖包
✅ 定义领域实体（Novel, AudioSegment, VoiceReference）
✅ 声明核心接口（INovelReader, ITtsService...）
✅ 实现服务类（ZhipuTtsService, AudioProcessor...）
✅ 配置依赖注入
✅ 编写主程序入口
```

**对话效率**：一句话 → 完整项目框架

---

### 第二幕：代码规范统一

**用户的反馈**：

> "所有的 using 不是都放到 GlobalUsings 中吗"

这是一个简短的风格偏好表达。AI 立即理解了背后的意图：

- 现代 C# 项目应使用 GlobalUsings
- 各个 .cs 文件不应包含独立的 using 语句
- 需要统一整个项目的引用管理

**AI 的执行**：

```diff
- // 每个文件中的独立 using
- using System;
- using System.IO;
- using Microsoft.Extensions.AI;

+ // GlobalUsings.cs 中的统一管理
+ global using System;
+ global using System.IO;
+ global using Microsoft.Extensions.AI;
```

**对话效率**：一句反馈 → 全局重构

---

### 第三幕：质量审查

**用户的请求**：

> "Code Review"

两个单词，触发了完整的代码审查流程。

**AI 发现的问题**：

| 问题 | 严重性 | 原因分析 |
|------|--------|----------|
| 服务生命周期不当 | 中 | `Singleton` 在配置热更新时存在隐患 |
| 同步文件读取 | 中 | 违反了 rules 中"必须异步 I/O"的要求 |
| 重试策略不完善 | 低 | 未处理 `TaskCanceledException` |

**修复后的改进**：

```csharp
// Before: 同步读取
var bytes = File.ReadAllBytes(filePath);

// After: 异步读取
var bytes = await File.ReadAllBytesAsync(filePath, cancellationToken);
```

**代码质量评分**：4.3/5 ⭐

**对话效率**：两个单词 → 全面审查 + 自动修复

---

### 第四幕：文档生成

**用户的意图**：

> "新增 Readme，以及我们对话的过程也写成一个子 readme"

**AI 的理解**：需要创建两层文档结构

```
README.md (主文档)
└── docs/DEVELOPMENT.md (开发过程记录)
```

**用户的澄清**：

> "不是，是与你对话的记录，专注于与你对话完成项目"

这一澄清让 AI 重新理解了文档的定位——不是纯技术文档，而是**对话过程的记录**。

**对话效率**：一次澄清 → 精准调整方向

---

## 🧠 规则文件：AI 的"大脑"

本项目的核心在于 **规则文件的预设**。规则文件相当于给 AI 注入了项目特定的"专业知识"。

### 规则文件结构

```markdown
## Codebase (代码库基础)
- 语言: C# (.NET 10)
- 架构: Clean Architecture

## Dependencies (核心依赖)
- Microsoft.Extensions.AI
- NAudio, Polly, Serilog...

## AI Coding Rules (编码准则)
- 必须使用 async/await
- 优先使用流式处理
- 结合 Polly 处理重试
```

### 规则的价值

| 方面 | 没有规则 | 有规则 |
|------|----------|--------|
| 技术栈选择 | AI 可能选择不同框架 | 精确遵循指定技术栈 |
| 架构风格 | 可能生成单体代码 | 严格遵循 Clean Architecture |
| 代码风格 | 随机的编码习惯 | 统一的现代 C# 风格 |
| 错误处理 | 基础异常处理 | 自动应用 Polly 重试 |

---

## 📊 开发统计

### 对话轮次与产出

| 对话 | 用户输入 | 产出 |
|------|----------|------|
| 1 | 1 句话 | 3 个项目、15+ 文件 |
| 2 | 1 句反馈 | 3 个 GlobalUsings + 全局重构 |
| 3 | 2 个单词 | 完整 Code Review + 4 处修复 |
| 4 | 2 句话 | 2 份文档（400+ 行） |

### 时间效率

```
传统开发预估: 4-6 小时
对话驱动开发: ~30 分钟

效率提升: 8-12 倍
```

---

## 🔮 思考与展望

### 对话驱动开发的适用场景

✅ **适合**：
- 原型快速搭建
- 标准化项目初始化
- 代码审查与重构
- 文档生成

⚠️ **需谨慎**：
- 复杂业务逻辑
- 性能关键代码
- 安全敏感模块

### 最佳实践总结

1. **准备好规则文件** — 清晰的规则是高质量输出的基础
2. **小步迭代** — 每次对话聚焦一个目标
3. **及时反馈** — 发现问题立即沟通，避免积累
4. **保持审查** — AI 生成的代码仍需人工复核

### 未来可能性

```
今天: 对话 → 代码
明天: 对话 → 测试 → 部署 → 监控
后天: 对话 → 完整的 DevOps 流程
```

---

## 🎬 结语

这份文档记录的不只是一个项目的诞生，而是一种新的开发范式的探索。

当我们从"编写代码"转向"描述意图"，开发的门槛在降低，效率在提升。但这并不意味着开发者的价值减少——相反，**理解需求、设计架构、审查质量**这些核心能力变得更加重要。

AI 是工具，对话是桥梁，而人的判断力和创造力，始终是开发的灵魂。

---

<div align="center">

*"最好的代码是不需要写的代码"*

*——但更好的是，用对话让 AI 帮你写*

</div>

---

*文档创建: 2025年12月14日*

*开发工具: Qoder AI Assistant*
